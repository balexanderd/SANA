#include <cassert>
#include "ParetoMode.hpp"

#include "../utils/utils.hpp"

#include "../arguments/measureSelector.hpp"
#include "../arguments/methodSelector.hpp"
#include "../arguments/graphLoader.hpp"

#include "../report.hpp"
#include <iostream>

void ParetoMode::run(ArgumentParser& args) {
    createFolders();
    Graph G1, G2;
    initGraphs(G1, G2, args);

    setArgsForParetoMode(args);
    MeasureCombination M;
    initMeasures(M, G1, G2, args);
    Method* method;
    method = initMethod(G1, G2, args, M);
    vector<Alignment> B = runParetoMode(method, &G1, &G2);
    cout << "Size: " << B.size() << endl;
    for(int i = 0; i < B.size(); i++) {
	cout << "Iteration: " << i << endl;
        Alignment A = Alignment(B[i]);
        cout << "One" << endl; 

        A.printDefinitionErrors(G1,G2);
        cout << "Two" << endl; 
        assert(A.isCorrectlyDefined(G1, G2) and "Resulting alignment is not correctly defined");
        cout << "Three" << endl; 

        string reportName = args.strings["-o"] + "_" + to_string(i);
        saveReport(G1, G2, A, M, method, reportName);
        cout << "Four" << endl;
        string localMeasuresFileName = args.strings["-localScoresFile"] + "_" + to_string(i);
        saveLocalMeasures(G1, G2, A, M, method, localMeasuresFileName);
        cout << "Five" << endl;
    }
    delete method;
}

string ParetoMode::getName(void) {
    return "ParetoMode";
}


void ParetoMode::createFolders(void) {
    createFolder("matrices");
    createFolder("matrices/autogenerated");
    createFolder("tmp");
    createFolder("alignments");
    createFolder("go");
    createFolder("go/autogenerated");
}

void ParetoMode::setArgsForParetoMode(ArgumentParser& args) {
    args.doubles["-ec"] = args.doubles["-s3"] = args.doubles["-tc"] = args.doubles["-sec"]
                        = args.doubles["-wec"] /*= args.doubles["-nodec"]*/ = args.doubles["local"]//= args.doubles["-noded"]
                        //= args.doubles["-edgec"] /*= args.doubles["-edged"]*/ = args.doubles["-go"]
                        //= args.doubles["-importance"] = args.doubles["-sequence"] = args.doubles["-graphlet"]
                        //= args.doubles["-graphletlgraal"] = args.doubles["-graphletcosine"] /*= args.doubles["-spc"]*/
                        = args.doubles["-nc"] = args.doubles["-mec"] /*= args.doubles["-ewec"]*/ = args.doubles["-ses"]
                        = 1;

    args.strings["-combinedScoreAs"] = "pareto";
    args.strings["-method"] = "sana";
}

vector<Alignment> ParetoMode::runParetoMode(Method *method, Graph *G1, Graph *G2) {
    cout << "Start execution of " << method->getName() << " in Pareto Mode." << endl;
    Timer T;
    T.start();
    //Method* METHOD = new SANA;
    //static_cast<SANA*>(METHOD)->derived_int;
    unordered_set<vector<unsigned short>*> *A = static_cast<SANA*>(method)->paretoRun();
    vector<Alignment> alignments;
    for(auto i = A->begin(); i != A->end(); i++)
        alignments.push_back( Alignment(**i) );
    //A->push_back(method->paretoRun());
    T.elapsed();
    cout << "Executed " << method->getName() << " in " << T.elapsedString() << endl;

    // Re Index back to normal (Method #3 of locking)

    // Needs to be reimplemented with unordered_set<vector<unsigned short>>*
    
    if(G1->hasNodeTypes()){
        G1->reIndexGraph(method->getReverseMap(G1->getNodeTypes_ReIndexMap()));
        alignments[0].reIndexAfter_Iterations(G1->getNodeTypes_ReIndexMap());
    }
    // if locking is enabled but hasnodeType is not
    else if(G1->getLockedCount() > 0){
         G1->reIndexGraph(method->getReverseMap(G1->getLocking_ReIndexMap()));
          alignments[0].reIndexAfter_Iterations(G1->getLocking_ReIndexMap());
    }
    method->checkLockingBeforeReport(alignments[0]);
    method->checkLockingBeforeReport(alignments[0]);
    return alignments;
}
    
